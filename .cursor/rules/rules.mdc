---
alwaysApply: true
---

# Принципы DRY · KISS · YAGNI для Python Telegram Bot

## Зачем
- Снижаем сложность, баги и стоимость сопровождения
- Ускоряем ревью и онбординг
- Улучшаем производительность (меньше кода — меньше работы)

---

## DRY (Don't Repeat Yourself)
**Цель:** отсутствует дублирование знаний/логики

### Правила
- Повтор 3+ раз → вынос в `app/services/` или `app/utils/`
- Повтор 2 раза → допускается, если абстракция ухудшит читаемость; пометь `# TODO: extract if reused`
- Дублирующиеся константы/цены → в `app/core/config.py` (Settings)
- Дублирующиеся тексты → в `app/templates/messages/texts.py`
- Дублирующиеся клавиатуры → в `app/bot/keyboards/`
- Один источник правды для схем данных (Pydantic models в `app/schemas/`)

### Антипаттерны
- Скопированный обработчик с мелкими отличиями
- Разные реализации одного и того же расчёта
- Дублирование логики валидации

### Чек-лист DRY (PR)
- [ ] Нет копипасты логики/текстов/клавиатур
- [ ] Константы/цены/настройки — в `config.py`
- [ ] Pydantic схемы — в `app/schemas/`
- [ ] Общие функции покрыты type hints

---

## KISS (Keep It Simple, Stupid)
**Цель:** минимально достаточная простота

### Правила
- Сначала простая реализация → оптимизация только по необходимости
- Предпочитай явный, линейный код вместо метапрограммирования
- Один уровень абстракции на функцию/модуль
- Не вводи универсальные решения там, где нужна локальная логика
- Функция не должна превышать 50 строк

### Антипаттерны
- Сверхобобщённый сервис, который сложнее, чем 2–3 простых функции
- Скрытая логика в декораторах, усложняющая отладку
- Чрезмерное использование `*args, **kwargs`

### Чек-лист KISS (PR)
- [ ] Решение очевидно из чтения кода
- [ ] Нет лишних абстракций/наследования
- [ ] Именование функций и переменных передаёт смысл без комментариев
- [ ] Async/await используется последовательно, без лишних вложенностей

---

## YAGNI (You Aren't Gonna Need It)
**Цель:** не писать то, что не нужно сейчас

### Правила
- Не реализуй «на вырост» фичи без согласованной задачи
- Pydantic модели минимальны: только используемые поля
- Мёртвый код/неиспользуемые функции — удалять
- Экспортируй из модуля только то, что реально используется
- Не добавляй FSM состояния «на будущее»

### Антипаттерны
- Параметры функций «на всякий случай»
- Полуготовые обработчики под «потом включим»
- Неиспользуемые поля в Pydantic схемах

### Чек-лист YAGNI (PR)
- [ ] Нет неиспользуемых функций/классов/состояний
- [ ] Нет «временных» абстракций без потребителя
- [ ] API функций соотнесён с реальным использованием

---

## Когда выносить в общую функцию/сервис
- **Правило трёх:** встретилось 3 раза → выносим в `app/services/` или `app/utils/`
- **Стабильность:** логика стабильна и понятна
- **Читаемость:** абстракция упрощает, а не усложняет код
- **Границы:** не смешиваем слои (handlers → services → schemas)

---
alwaysApply: true
---

# Диагностика и ответы

- При баге: сначала выяви точную причину, затем фикс (пофайловый патч)
- Минимальные примеры — только если ускоряют понимание
- Не выдумывай несуществующие API aiogram/pydantic/weasyprint
- Если чего-то нет — предложи минимальную реализацию в рамках проекта

---
alwaysApply: true
---

# Стиль кода Python

## Форматирование
- Следуй PEP 8
- Используй `ruff` для линтинга и форматирования
- Максимальная длина строки: 100 символов
- Функция не должна превышать 50 строк
- Обработчик (handler) не должен превышать 80 строк
- Избегай комментарий в коде

## Импорты
- Порядок: stdlib → third-party → local
- Группы разделены пустой строкой
- Используй абсолютные импорты: `from app.services.calculator import calculate_total`
- Избегай `from module import *`
```python
# Правильно
import asyncio
from datetime import datetime

from aiogram import Router, F
from aiogram.types import Message

from app.core.config import settings
from app.services.calculator import calculate_total
```

## Именование
- Модули/пакеты: `snake_case` (например: `chat_logger.py`, `pdf_generator.py`)
- Классы: `PascalCase` (например: `CalculationStates`, `PDFGenerator`)
- Функции/переменные: `snake_case` (например: `get_user_history`, `total_cost`)
- Константы: `UPPER_SNAKE_CASE` (например: `MAX_PRICE`, `DEFAULT_TIMEOUT`)
- Приватные методы/функции: `_leading_underscore`

## Type Hints
- Обязательны для всех публичных функций и методов
- Используй современный синтаксис Python 3.13: `list[str]`, `dict[str, int]`, `str | None`
- Pydantic модели автоматически валидируют типы
```python
# Правильно
async def calculate_total(
    area: float,
    price_per_m2: int
) -> float:
    return area * price_per_m2

# Неправильно (нет type hints)
async def calculate_total(area, price_per_m2):
    return area * price_per_m2
```

## Async/Await
- Все I/O операции — асинхронные
- Обработчики aiogram — всегда async
- Используй `await` для всех async функций
- Не блокируй event loop синхронными операциями

## Docstrings
- Публичные функции/классы — обязательны (Google style)
- Приватные — опционально, если логика неочевидна
```python
async def calculate_ceiling_cost(
    area: float,
    fabric_type: str,
    profile_type: str
) -> dict[str, float]:
    """Рассчитывает полную стоимость натяжного потолка.
    
    Args:
        area: Площадь помещения в м²
        fabric_type: Тип полотна ('MSD' или 'BAUF')
        profile_type: Тип профиля
        
    Returns:
        Словарь с детализацией стоимости
    """
```

## Зависимости
- Если без них можно — не добавляй
- Если добавляешь — укажи назначение и команду: `poetry add package-name`
- Проверяй совместимость с Python 3.13

## Переиспользование
- Перед новой реализацией проверь `app/services/` и `app/utils/`
- Общие клавиатуры — в `app/bot/keyboards/`
- Общие тексты — в `app/templates/messages/`

---
alwaysApply: true
---

# Архитектура проекта

## Структура директорий
```
app/
├── core/              # Конфигурация (Settings, константы)
├── bot/               # Telegram bot логика
│   ├── handlers/      # Обработчики команд и FSM
│   ├── keyboards/     # Inline/Reply клавиатуры
│   ├── middlewares/   # Middleware (логирование, админ-уведомления)
│   └── states.py      # FSM состояния
├── services/          # Бизнес-логика (расчёты, PDF, логирование)
├── schemas/           # Pydantic модели данных
├── templates/         # Jinja2 шаблоны и текстовые сообщения
└── utils/             # Вспомогательные функции
```

## Слои и зависимости
```
handlers → services → schemas
    ↓         ↓
keyboards   core/config
    ↓
templates/messages
```

**Правила:**
- `handlers/` — только обработка событий Telegram, не содержит бизнес-логику
- `services/` — вся бизнес-логика (расчёты, генерация PDF, логирование)
- `schemas/` — Pydantic модели для валидации данных
- `core/config.py` — единый источник настроек (цены, токены)
- `keyboards/` — чистые функции, возвращающие клавиатуры
- `templates/messages/` — текстовые константы

## Не смешивай слои
- ❌ Расчёты в handlers
- ❌ Обработка Telegram событий в services
- ❌ Прямое использование `settings` в handlers (передавай через параметры)

---
alwaysApply: true
---

# Общие правила ответа ассистента

## Стиль и язык
- **Язык:** русский
- **Тон:** конкретно и по делу, без воды

## Структура ответа
- **A. План** — 3–7 коротких шагов
- **B. Изменения** — пофайловые патчи: `путь/к/файлу.py` → diff. Пометка `# new file` для новых, `# delete file` для удалённых
- **C. Почему** — 2–5 тезисов (архитектура, производительность, читаемость, безопасность)
- **D. Проверки** — краткий чек-лист: `ruff check`, запуск бота, сценарий тестирования

## При неоднозначности
- Сделай лучшее предположение
- Выполни частичную реализацию и пометь места для уточнения `# TODO: уточнить`

## Запреты
- Не вводи несуществующие API aiogram/pydantic/weasyprint
- Не добавляй зависимости без острой необходимости
- Не используй базы данных (PostgreSQL/MongoDB/Redis) — только MemoryStorage

## Быстрый шаблон для ревью (коммент к PR)
- **DRY:** есть ли повтор ≥3 раз? можно ли вынести в `services/` или `utils/`?
- **KISS:** можно ли упростить без потери требований?
- **YAGNI:** что убрать сейчас, не теряя ценности?
- **Type hints:** все публичные функции типизированы?
- **Async:** все I/O операции асинхронные?
- **Итог:** какие 1–2 правки дадут наибольшую окупаемость?